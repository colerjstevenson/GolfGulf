
<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8' />
    <title>Toronto Census Explorer</title>
    <meta name='viewport' content='width=device-width,initial-scale=1' />
    <link rel='stylesheet' href='https://unpkg.com/leaflet@1.9.4/dist/leaflet.css' />
    <style>
        body,html { margin:0; padding:0; height:100%; font-family:system-ui,Arial,sans-serif; }
        #app { display:flex; height:100%; }
        #sidebar { width:340px; overflow:auto; border-right:1px solid #ccc; padding:12px; box-sizing:border-box; background:#fafafa; }
        #map { flex:1; }
        .category { margin-bottom:10px; }
        .category h3 { margin:4px 0; font-size:14px; cursor:pointer; }
        .metrics { display:none; margin-left:8px; }
        .metric-btn { display:block; text-align:left; width:100%; border:0; background:#fff; padding:4px 6px; margin:2px 0; cursor:pointer; font-size:12px; border-radius:4px;}
        .metric-btn:hover { background:#e3f2fd; }
        #search { width:100%; padding:6px; margin-bottom:8px; }
        #legend { padding:6px; background:white; border:1px solid #999; font-size:12px; line-height:1.2; }
        #detail { padding:6px; font-size:12px; border-top:1px solid #ddd; }
        .hist-bar { height:8px; background:#90caf9; display:inline-block; margin-right:1px; }
    </style>
</head>
<body>
<div id='app'>
    <div id='sidebar'>
        <input id='search' type='text' placeholder='Search metrics…' />
        <label style='display:block;margin:6px 0 8px 0;font-size:12px;'>
            <input type='checkbox' id='lagToggle' /> Spatial Lag Mode
        </label>
        <div id='currentMetricDisplay' style='font-size:12px;margin:4px 0 8px 0;color:#333'><em>No metric selected</em></div>
        <div id='categories'></div>
        <div id='detail'><em>Click a tract for details…</em></div>
    </div>
    <div id='map'></div>
</div>
<script src='https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'></script>
<script>
const ASSET_ROOT = '../data/censusShape/toronto/web_assets';
let tractLayer = null;
let currentMetric = null; // slug
let currentMode = 'raw'; // 'raw' | 'lag'
let metricsCache = new Map(); // key(slug|mode) -> { ctuid: value }
let skipReasonsCache = new Map(); // slug -> { ctuid: reason }
let indexData = null; // metrics index
let metricMeta = new Map(); // slug -> {name, stats}
let coursesLayer = null;
function cacheKey(slug, mode){ return slug + '::' + (mode||'raw'); }
const map = L.map('map').setView([49.25, -123.1], 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
async function fetchJSON(path) {
    try {
        const r = await fetch(path);
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const txt = await r.text();
        const first = txt.trim().charAt(0);
        if (first !== '{' && first !== '[') throw new Error('Invalid JSON start');
        return JSON.parse(txt);
    } catch (e) {
        console.error('Fetch failed', path, e);
        const warn = document.getElementById('detail');
        if (warn) warn.innerHTML = '<span style="color:#b00">Failed to load ' + path + ': ' + e.message + '. If opened with file://, run a local server (python -m http.server).</span>';
        throw e;
    }
}
function clamp01(x){ return x<0?0:(x>1?1:x); }
// Color helpers: use blue for raw, green for spatial lag
function colorFromT(t){
    const hue = (currentMode === 'lag') ? 140 : 210; // green vs blue
    const light = 92 - 55*t; // 92% -> 37%
    return 'hsl(' + hue + ',70%,' + light.toFixed(1) + '%)';
}
function colorScale(val, min, max) {
    if (val==null || isNaN(val)) return '#eee';
    const t = clamp01((val - min) / (max - min + 1e-9));
    return colorFromT(t);
}
function buildRamp(min, max) {
    const steps = 6;
    let html = '<div style="margin-top:4px;display:flex;gap:2px;align-items:center">';
    for (let i=0;i<steps;i++){
        const t = i/(steps-1);
        const v = min + t*(max-min);
        html += '<span style="display:inline-block;width:20px;height:10px;background:'+colorScale(v,min,max)+'"></span>';
    }
    html += '</div>';
    return html;
}
function applyMetric(metricSlug, stats) {
    currentMetric = metricSlug;
    const key = cacheKey(metricSlug, currentMode);
    const values = metricsCache.get(key);
    // Compute min/max from the actual values present in the visible layer
    const arrAll = Object.values(values).map(v => Number(v)).filter(v => isFinite(v));
    let min = stats.min, max = stats.max;
    if (arrAll.length > 0) {
        arrAll.sort((a,b)=>a-b);
        min = arrAll[0];
        max = arrAll[arrAll.length - 1];
    }
    // Determine scale mode: min-max vs quantile fallback when spread is tight or flat
    let useQuantiles = false;
    // Estimate p10/p90 from actual values for decision and legend
    let p10 = (stats.p10 ?? min), p90 = (stats.p90 ?? max);
    if (arrAll.length >= 5) {
        const qidx = q => arrAll[Math.max(0, Math.min(arrAll.length-1, Math.floor(arrAll.length*q)))];
        p10 = qidx(0.10);
        p90 = qidx(0.90);
    }
    if (!isFinite(min) || !isFinite(max) || min === max) {
        useQuantiles = true;
    } else if (isFinite(p10) && isFinite(p90)) {
        useQuantiles = (p90 - p10) < (max - min) * 0.2; // tight middle spread -> quantiles for contrast
    }
    // Precompute quantile edges if needed
    let qEdges = null;
    if (useQuantiles) {
        const arr = arrAll; // already sorted
        if (arr.length >= 5) {
            const idx = q => arr[Math.max(0, Math.min(arr.length-1, Math.floor(arr.length*q)))];
            qEdges = [idx(0.05), idx(0.25), idx(0.5), idx(0.75), idx(0.95)];
        } else {
            // Fallback to min-max if too few values
            useQuantiles = false;
        }
    }
    const getColor = (v) => {
        if (v==null || !isFinite(v)) return '#eee';
        if (useQuantiles) {
            const val = Number(v);
            let t = 0.1;
            if (val <= qEdges[0]) t = 0.1;
            else if (val <= qEdges[1]) t = 0.3;
            else if (val <= qEdges[2]) t = 0.5;
            else if (val <= qEdges[3]) t = 0.7;
            else t = 0.9;
            return colorFromT(t);
        }
        return colorScale(Number(v), min, max);
    };
    tractLayer.eachLayer(l => { const ct = l.feature.properties.CTUID; const v = values[ct]; l.setStyle({ fillColor: getColor(v), fillOpacity:0.75, weight:0.2, color:'#333' }); });
    const legend = document.getElementById('legend');
    if (legend) legend.remove();
    const lg = L.control({position:'bottomright'});
    const meta = metricMeta.get(metricSlug) || {name: metricSlug};
    const disp = document.getElementById('currentMetricDisplay');
    const modeLabel = currentMode === 'lag' ? ' (Spatial Lag)' : '';
    if (disp) disp.textContent = meta.name + modeLabel + ' (min ' + (isFinite(min)?min.toFixed(2):'—') + ', max ' + (isFinite(max)?max.toFixed(2):'—') + ')';
    lg.onAdd = () => {
        const div = L.DomUtil.create('div',''); div.id='legend';
        if (useQuantiles && qEdges) {
            div.innerHTML = '<strong>' + meta.name + '</strong><br>Quantile bins (approx):<br>' +
                qEdges.map((q,i)=> (i? '&nbsp;':'') + (i<qEdges.length-1? q.toFixed(2) : ('≥ ' + q.toFixed(2)))).join('') +
                buildRamp(qEdges[0], qEdges[qEdges.length-1]);
        } else {
            div.innerHTML = '<strong>' + meta.name + '</strong><br>Min: ' + (isFinite(min)?min.toFixed(2):'—') + '<br>Max: ' + (isFinite(max)?max.toFixed(2):'—') + buildRamp(min, max);
        }
        return div;
    };
    lg.addTo(map);
}
function loadMetric(metricSlug, stats) {
    if (!tractLayer) { console.warn('Geometry layer not ready yet.'); return; }
    const key = cacheKey(metricSlug, currentMode);
    if (metricsCache.has(key)) { applyMetric(metricSlug, stats); return; }
    const path = currentMode === 'lag' ? (ASSET_ROOT + '/metrics/' + metricSlug + '__lag.json')
                                      : (ASSET_ROOT + '/metrics/' + metricSlug + '.json');
    fetchJSON(path).then(data => {
        metricsCache.set(key, data);
        // Load skip reasons if in lag mode
        if (currentMode === 'lag') {
            const skipPath = ASSET_ROOT + '/metrics/' + metricSlug + '__lag_skip.json';
            fetchJSON(skipPath).then(skipData => {
                skipReasonsCache.set(metricSlug, skipData);
                applyMetric(metricSlug, stats);
            }).catch(() => {
                // No skip file, proceed anyway
                applyMetric(metricSlug, stats);
            });
        } else {
            applyMetric(metricSlug, stats);
        }
    })
    .catch(err => {
        if (currentMode === 'lag') {
            const warn = document.getElementById('detail');
            if (warn) warn.innerHTML = '<span style="color:#b00">Lag variant not available for this metric.</span>';
        }
    });
}
function buildUI() {
    const catContainer = document.getElementById('categories');
    catContainer.innerHTML='';
    indexData.categories.forEach(cat => {
        const wrap=document.createElement('div');
        wrap.className='category';
        const h=document.createElement('h3');
        h.textContent=cat.category;
        h.onclick=()=>{ mDiv.style.display = mDiv.style.display==='none'?'block':'none'; };
        const mDiv=document.createElement('div');
        mDiv.className='metrics';
        cat.metrics.forEach(m => {
            const metaStats = (currentMode==='lag' && m.lagStats)? m.lagStats : m.stats;
            metricMeta.set(m.slug, {name:m.name, stats:metaStats, lagStats:m.lagStats||null});
            const btn=document.createElement('button');
            btn.className='metric-btn';
            btn.textContent=m.name + (m.lagStats?'' : '');
            btn.onclick=()=>{
                const stats = (currentMode==='lag' && m.lagStats)? m.lagStats : m.stats;
                loadMetric(m.slug, stats);
            };
            mDiv.appendChild(btn);
        });
        wrap.appendChild(h);
        wrap.appendChild(mDiv);
        catContainer.appendChild(wrap);
    });
    const toggle = document.getElementById('lagToggle');
    if (toggle && !toggle._wired) {
        toggle._wired = true;
        toggle.addEventListener('change', () => {
            currentMode = toggle.checked ? 'lag' : 'raw';
            // Refresh current metric if selected
            try {
                buildUI(); // refresh to update stats references
                if (currentMetric) {
                    const meta = metricMeta.get(currentMetric);
                    const stats = (currentMode==='lag' && meta && meta.lagStats)? meta.lagStats : (meta? meta.stats : null);
                    if (stats) loadMetric(currentMetric, stats);
                }
            } catch(_) {}
        });
    }
}
function filterMetrics(q) { q=q.toLowerCase(); document.querySelectorAll('.metric-btn').forEach(btn=>{ btn.style.display = btn.textContent.toLowerCase().includes(q)?'block':'none'; }); }
document.getElementById('search').addEventListener('input', e => filterMetrics(e.target.value));
fetchJSON(ASSET_ROOT + '/metrics_index.json').then(idx => { 
    indexData = idx; 
    buildUI(); 
    // Auto-load first metric if available
    try {
        const firstCat = indexData.categories[0];
        const firstMetric = firstCat && firstCat.metrics[0];
        if (firstMetric) loadMetric(firstMetric.slug, firstMetric.stats);
    } catch(e) { console.warn('Auto-load metric failed', e); }
}).catch(()=>{});
fetchJSON(ASSET_ROOT + '/tracts.geojson').then(gj => {
    if (!gj.features || !gj.features.length) {
        const warn = document.getElementById('detail');
        if (warn) warn.innerHTML = '<span style="color:#b00">No tract features loaded. Check GeoJSON generation.</span>';
        console.error('Empty GeoJSON feature collection');
        return;
    }
    tractLayer = L.geoJSON(gj, { 
        style:()=>({fillColor:'#ccc',weight:0.4,color:'#555',fillOpacity:0.5}), 
        onEachFeature:(f,l)=>{ 
            l.on('click',()=>showDetail(f));
            l.on('mouseover', (e)=> showHover(f, l));
            l.on('mouseout', ()=> { if (l.closeTooltip) l.closeTooltip(); });
        } 
    }).addTo(map);
    try { tractLayer.bringToBack(); } catch(_) {}
    map.fitBounds(tractLayer.getBounds());
    console.log('Loaded tracts:', gj.features.length);
}).catch(e => {
    console.error('Failed to load tracts.geojson', e);
    const warn = document.getElementById('detail');
    if (warn) warn.innerHTML = '<span style="color:#b00">Failed to load tract geometry. Serve over HTTP and ensure path is correct.</span>';
});

// Load golf courses overlay (if present)
fetchJSON(ASSET_ROOT + '/golf_courses.geojson').then(gj => {
    coursesLayer = L.geoJSON(gj, {
        style: (feature) => {
            // Render all golf course polygons as translucent red shapes
            return {
                fillColor: '#e53935',
                fillOpacity: 0.35,
                color: '#b71c1c',
                weight: 1.5,
                opacity: 0.8
            };
        },
        onEachFeature: (f,l) => {
            const p = f.properties || {};
            const title = p.name || 'Golf Course';
            const addr = p.address ? ('<div>'+p.address+(p.city?(', '+p.city):'')+'</div>') : '';
            const meta = [p.access, p.holes?('Holes: '+p.holes):null, p.par?('Par: '+p.par):null].filter(Boolean).join(' · ');
            const nb = Number(p.nearby) === 1 ? '<div><small style="color:#b71c1c">Nearby (outside city boundary)</small></div>' : '';
            const links = (p.website||p.url)?('<div style="margin-top:4px">'+(p.website?('<a href="'+p.website+'" target="_blank">Website</a>'):'') + (p.website&&p.url?' | ':'') + (p.url?('<a href="'+p.url+'" target="_blank">Link</a>'):'') + '</div>') : '';
            l.bindPopup('<b>'+title+'</b><br>'+addr+(meta?('<small>'+meta+'</small>'):'')+nb+links);
        }
    }).addTo(map);
    try { coursesLayer.bringToFront(); } catch(_) {}
    // Optional: add a simple control to toggle
    try { L.control.layers({}, {'Golf Courses': coursesLayer}, {collapsed:true}).addTo(map); } catch(_){}
}).catch(()=>{ /* optional layer, ignore errors */ });
function formatNum(x){ if (x==null || isNaN(x)) return '—'; const n = Number(x); return Math.abs(n) >= 1000 ? n.toLocaleString() : n.toString(); }
function showDetail(feature) {
    const ct=feature.properties.CTUID; const panel=document.getElementById('detail'); if (!indexData) { panel.innerHTML='Loading categories…'; return; }
    if (!currentMetric) { panel.innerHTML = '<strong>Tract: ' + ct + '</strong><br><em>Select a metric to see its value.</em>'; return; }
    const meta = metricMeta.get(currentMetric) || {name: currentMetric};
    const key = cacheKey(currentMetric, currentMode);
    const vals = metricsCache.get(key) || {};
    const v = vals[ct];
    let valueDisplay = formatNum(v);
    if (currentMode === 'lag' && (v == null || !isFinite(v))) {
        const skipReasons = skipReasonsCache.get(currentMetric) || {};
        const reason = skipReasons[ct];
        if (reason) {
            valueDisplay = '<em style="color:#999">Skipped: ' + reason + '</em>';
        }
    }
    panel.innerHTML = '<strong>Tract: ' + ct + '</strong><br><div><b>'+ meta.name + ':</b> ' + valueDisplay + '</div>';
}

function showHover(feature, layer) {
    const ct = feature.properties.CTUID;
    let content = 'Tract: ' + ct;
    if (currentMetric) {
        const meta = metricMeta.get(currentMetric) || {name: currentMetric};
        const key = cacheKey(currentMetric, currentMode);
        const vals = metricsCache.get(key) || {};
        const v = vals[ct];
        let valueDisplay = formatNum(v);
        if (currentMode === 'lag' && (v == null || !isFinite(v))) {
            const skipReasons = skipReasonsCache.get(currentMetric) || {};
            const reason = skipReasons[ct];
            if (reason) {
                valueDisplay = '<em style="color:#999">Skipped: ' + reason + '</em>';
            }
        }
        content = '<div><b>' + meta.name + '</b><br>' + valueDisplay + '</div>';
    } else {
        content = '<em>Select a metric…</em>';
    }
    if (layer && layer.bindTooltip) {
        layer.bindTooltip(content, {sticky:true}).openTooltip();
    }
}
</script>
</body>
</html>
    